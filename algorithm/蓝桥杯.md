# 蓝桥杯

## 做题套路

> 1. 题目描述  -----> 抽象出考察的模型，得知出题人想问的问题是什么
> 2. 回忆解决该模型问题的算法

### 时间复杂度的判断

> 对于`c++` 来说 1s 能执行 一亿次，也就是==10^8^==次
>
> + 一般来说, 1s内执行的次数在10^7^和10^8^之内，就可以在1s内通过

### 空间复杂度的判断

> 1 byte = 8 bit
>
>    字节        位
>
> int  = 4byte
>
> char = 1byte
>
> longlong = 8byte
>
> float = 4byte
>
> 64 MB = 64*2^20^  byte 
>
> = 6.4*10^7^byte

### 由数据范围反推算法复杂度以及算法内容

一般ACM或者笔试题的时间限制是1秒或2秒。
在这种情况下，C++代码中的操作次数控制在 10^7^∼10^8^为最佳。

下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：

> 详细见acwing 分享《由数据范围反推算法复杂度以及算法内容》
>
> `int`的数据范围大概是 2*10^9^大小
>
> `longlong`的数据范围是+-10^18^次方之间
>
> 
>
> 算法题中的数据范围就像是出题人给的提示一样,要很快的由数据范围得到应该使用的算法。

### 小技巧

````c++
printf scanf 的速度比 cin cout 一样
#当数据范围大于10^5 时用printf scanf会快很多
````



## 递归和递推

### 递归

​      一个函数自己调用自己

> 例如斐波那契数列
>
> ````c++
> #include <iostream>
> #include <cstdio>
> #include <cstring>
> 
> using namespace std;
> 
> int f(int n)
> {
>     if (n == 1) return 1;
>     if (n == 2) return 2;
>     return f(n - 1) + f(n - 2);
> }
> int main()
> {
>     int n;
>     cin >> n;
>     cout << f(n) <<endl;
>     return 0;
> }
> 
> ````
>
> 所有递归都可以转化成一棵递归搜索树

> 递归最重要的是顺序，这个顺序要能不重不漏的完成题目的要求。
>
> 递归实现指数型枚举：（深度优先 dfs）
>
> + 考虑每个数选或者不选
> + 每个数的选择状态可以开一个长度为N的数组来进行记录
>
> 递归实现排列型枚举：（深度优先 dfs）排列要考虑顺序
>
> + 依次枚举每个位置放哪个数
>
> 递归实现组合型枚举：（深度优先 dfs）组合不用考虑顺序
>
> + 要保证所有相邻的数都是后一个比前一个大
>
> 	dfs函数的参数：
>
> 	+ 首先是位置数组
> 	+ 当前枚举的位置
> 	+ 当前最小可以从哪个数开始枚举
>
> ==深度优先搜索题相当于是一个模板==：
>
> + 画出其递归搜索树即可

### 递推

递推是：先求子问题，然后用子问题将原问题直接求出来

> ````c++
> f(n) = f(n-1) + f(n-2)  //递归是将求f(n) 转为f(n-1) 和f(n-2)这两个小问题
> //而递推是先将f(n-2) 和f(n-1) 求出 然后二者相加即可得到f(n)
> ````
>
> 就比如对斐波那契数列这道题，就可以用数组，将所有数推出来之后存在数组中。

### 剪枝

在达到某条件后，提前将不符合条件的去掉。

### 由初始状态到目标状态这一类型题目

> 部分可以用宽松即 bfs

### 开关问题

> 共同点：
>
> + 同一个开关只按一次
> + 顺序无关紧要

## 小知识点

### 字典序

> 假设有两行字符串
>
> a1 a2 a3 ……
>
> b1 b2 b3 ……
>
> 从a1 和b1开始比较，若两者相等，则继续比较a2 和b2，一直比较到不同的字符为止，若都相同则两字符串相等
>

## 二分

每次遇到题目要先进行分析，分析后才能知道能不能使用二分法。

下面是整数二分

> 1. 确定一个区间，是目标值一定在区间中。
> 2. 找一个性质满足：
> 	1. 性质具有二段性
> 	2. 答案是二段性的分界点
>
> 两种情况：
>
> + 答案是左边区间的右端点，这时用左侧的模板
>
> ````c++
> while(L < R)
> {
>     M = (L+R+1)/2;  //这是用当前整个区间分出来的中点
>     if(M在左侧)
>     {
>         L = M;  //因为答案是红色区间的右端点，且M在红色区间中，所以此时 M 左边的内容都是无用的，所以将L向右更新 
>     }
>     else R = M - 1; // M 在绿色区域内，所以 M 及其右边的内容都是无用的，所以将 R 向左更新
> }
> ````
>
> ![image-20240305102821015](../../../AppData/Roaming/Typora/typora-user-images/image-20240305102821015.png)
>
> + 答案是右边区间的左端点，这时用右侧的模板
>
> ````c++
> while(L < R)
> {
>     M = (L + R) / 2;
>     if(M 在右侧)
>     {
>         R = M;
>     }
>     else L = M+1;
> }
> ````
>
> ![image-20240305105113603](../../../AppData/Roaming/Typora/typora-user-images/image-20240305105113603.png)

### 实数二分

> 能正好分割到中点，因为实数是连续的。
>
> 实数二分模板：
>
> ````c++
> while(R - L > 1e^-6)  //当区间变得很小很小时,循环结束
> {
>     if(ans 在右区间)
>     {
>         L = m;
>     }    
>     else R = m;
> }
> 
> ````
>
> 

## 前缀和

其处理的问题就是，尽快求出一个静态数组的某区域的和。  只能处理静态数组，数组的值不能修改。

> 该算法是一种重要思想；
>
> 可以求出所有的前缀和：
>
> + 一维前缀和：
>
> ````c++
> s0 = 0
> s1 = a1
> s2 = a1+a2
> si = a1+a2+ ....+ai      si = si-1+ai
> ````
>
> + 二维前缀和:
>
> 	![image-20240311230705176](../../../AppData/Roaming/Typora/typora-user-images/image-20240311230705176.png)
>
> 	先求出二维前缀和，在通过二维前缀和的值去求目标值.

## 数学类题目

### 裴蜀定理

> 当p 和 q 的最大公约数为d 时
>
> 则一定有 ap + bq = d      (一定能找到整数a和b使该式满足)    

### 作数学公式尽力分析

> 例如分析最大公约数等等

### 打表找规律

> 先作一个简单的爆搜，能够过一部分数据，这样可以通过这些数据画一个表找规律

## DP

### 闫式DP分析法（从集合角度分析DP问题）

该方法类似于列出一个草稿进行分析计算

> DP问题大致求两类：1. 最值   2. 个数
>
> 经过两步： 
>
> 1. 化零为整 ： 把一堆具有共性的零散的方案放入一个集合中
> 2. 化整为零： 想要得到结果 ，还要集合化分

### 背包问题

在某种限制之下得到一种最好的

> 是组合模型    

## 枚举，模拟和排序

> 闰年判断方法：
>
> + 世纪年：能被400整除的是闰年
> + 普通年：不能被100整除但是能被4整除的是闰年。
>
> 曼哈顿距离: abs(x1 - x2) + abs(y1 - y2)
>
> 欧几里得距离 ：根号下 x1 - x2的平方 + y1 - y2 的平方



## 贪心算法

> + 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，**不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解**。
> + **问题的最优子结构性质是该问题可用贪心算法求解的关键特征**。

## 双指针算法

> 就是对双重循环的优化

## BFS

> 走迷宫这类问题就是经典的BFS问题，可以背板子。
>
> 可以画一个宽搜树出来。（也可以是一个环）
>
> 要有一个判重数组，来确保不会重复。
>
> **相比于DFS，BFS能找到一条最短路径**

## 筛质数

> ![image-20240410182509593](../../../AppData/Roaming/Typora/typora-user-images/image-20240410182509593.png)
