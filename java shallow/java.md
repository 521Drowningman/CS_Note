# 数组

## 做补充

> 创建无法确定大小的数组 `int a[]={}`;

# 字符串

## 一、常用API：

> ```java
> hasNext(); //判断还有没有字符串继续输入 boolean类型
> toString(); //和数组一样 第一个字符的下标是0， 所以如果长度是6，则下标5为最后一个字符
> equalsIgnoreCase();//比较字母的长度和字符是否相同，且不区分大小写
> 
> ```
>
> ![image-20231213203741575](../../../AppData/Roaming/Typora/typora-user-images/image-20231213203741575.png)
>
> 

## 二、String和StringBuffer和StringBuilder的区别

> 1. `String`不能被修改，如果打算修改字符串，可以使用`StringBuilder`和`StringBuffer`；
> 1. `StringBuffer`线程安全，速度较慢；
> 1. `StringBuilder`线程不安全，速度较快。





----

# 函数

## 一、实参和形参：

> 1.  实参和形参的个数，类型必须相同；
> 2. 传入的参数即使类型不一样，如果存在隐性转换方式，那么也可传入；

## 二、变量

> 1. 函数内定义的变量为局部变量，只能在函数内部使用。 另一个函数使用不了。
>
> ````java
> //例如
> private static void f1(){
>     int x=3;
> }
> 
> private static void f2(){
>     System.out.println(x); //这里再调用f2的时候是一定报错的
> }
> ````
>
> 2. 定义在类中的变量为成员变量，可以在类的所有成员函数中调用。（ ==不是在主函数里定义==）
> 3. 当局部变量与全局变量重名时，会优先使用局部变量。



## 三、参数传递

### 3.1值传递

> 1. 八大基本数据类型和`String`（不支持修改，即使修改了，其实是开辟一个新的地址）类型等采用值传递。
> 2. 将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。

### 3.2引用传递

> 1. 除`String`以外的数据类型的对象，例如数组、`StringBuilder`等采用引用传递。
> 2. 将实参的引用（地址）传给形参，通过引用找到变量的真正地址，然后对地址中的值修改。所以此时对形参的修改会影响实参的初始值。
> 3. 这里引用传递并不需要像 c语言中要用取地址符号，主要看该数据类型是否满足引用传递。
> 4. 本质是传递的地址。
>


## 四、返回类型和return语句

`return` 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。

> ````java
> return;  //无返回值 但是可以结束当前函数； 用在主函数中时，主函数执行到return语句后会直接结束，不执行后面的操作
> return expression; //有返回值，这里返回一个表达式，但是表达式的值其结果的类型要和函数返回的类型相同
> ````
>
> 

### 4.1无返回值函数

> + 没有返回值的`return`语句只能用在返回类型是`void`的函数中。
> + 在这类函数的最后一句后面会隐式地执行`return`。
> + `void`函数如果想在它的中间位置提前退出，可以使用`return`语句。

### 4.2有返回值函数

> + 只要函数的返回类型不是`void`，则该函数内的每个分支都必须有`return`语句，且每条`return`语句都必须返回一个值。
> + `return`语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换函数的返回类型。


## 五、函数重载

> + 在同一个类中存在多个函数，函数名称相同但参数列表不同。
> + 编译器会根据实参的类型选择最匹配的函数来执行。

## 六、函数递归

> + 在一个函数内部，也可以调用函数本身。
> + 当分析不清楚时，可以画一个递归搜索树。



----

# 类与接口

## 一、类与对象

类定义一种全新的数据类型，包含一组变量和函数；对象是类这种类型对应的实例。

### 1.1源文件声明规则

> 1. 一个源文件中只能有一个`public`类。
> 1. 一个源文件可以有多个非`public`类。
>
> ```java
> public class Xx{  //一个文件中只能有一个class前面有public
> }
> 
> class Point{  //是可以定义的  像这种没有限定修饰符的类就可以在同一个包中使用
> }
> ```
>

### 1.2类的定义

> + `public`: 所有对象均可以访问； 
> + `private`: 只有本类内部可以访问；         （如1.1中定义了两个类，若Point 类中的成员是`private` 则Xx中无法访问该成员）
> + `protected`：同一个包或者子类中可以访问；
> + 不添加修饰符：在同一个包中可以访问。
> + ==静态== 指带有`static`修饰符的成员变量或者函数：
> 	1. static 方法是类的方法，不需要创建对象就可以被调用。     （可以被对象或类调用）
> 	2. 非static 方法是对象的方法，只有对象被创建出来后才可以被使用。  （只能被对象调用）
> + 静态函数中只能调用静态函数/变量；普通函数中既可以调用普通函数/变量，也可以调用静态函数/变量。
> + **public > protected** > default > private

### 1.3类的继承和多态

> 1. 每个类只能继承一个类 (只能有一个父类)
>
> ````java
> class xx extends xxx{  //就是xx继承自xxx
> 
> }
> ````
>
> 2. **多态指的是同一个方法调用，由于对象不同可能会有不同的行为;**
> 2. 子类可以对继承来的方法进行重写。
> 2. `super`在程序中表示当前对象的父类。
> 2. 父类中private修饰的私有变量和方法，子类不能继承。

### 1.4类的构造函数

> 1. 构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可。
> 2. 构造函数没有返回值类型。
> 3. 不能被继承。
> 4. ![image-20231209222545905](../../../AppData/Roaming/Typora/typora-user-images/image-20231209222545905.png)
>

### 1.5抽象类

> +  `abstract`类，不能初始化实例。
> 

### 1.6匿名内部类

把子类继承父类，重写父类中的方法，创建子类对象，合成了一步完成，减少了其中创建子类的过程。

`匿名内部类的格式：父类/接口 对象 = new 父类/接口（）{  重写父类/接口中的方法  }；` 

## 二、接口

### 如何理解？

> 我们在编写程序的时候，有时候会有一些想法，或者说「规矩」，我们希望自己编写的类能够遵守某些「规矩」。有时候，我们希望某个类中一定要有某些功能，比如说，我们创建了一个「汽车类」，那么我们就希望所有的「汽车类」在创建的时候能够遵守这样一些规矩：
>
> 1. 必须有品牌属性（Field）
> 2. 必须有车型属性（Field）
> 3. 必须有行驶功能（Method）
> 4. 必须有刹车功能（Method）
>
> 这些规矩就是我们在创建类的时候必须要遵守，那么我们就可以将这些指导类的创建的规矩放在一个新的框架中，这个框架在Java中就叫做「接口（interface）」，以后当我们想要创建一个符合这些规矩的类的时候，就需要先引用这些「接口」。
> 

### 作用

> 1. 主要用来定义类中所需包含的函数。
> 2. 接口也可以继承其他接口，一个类可以实现多个接口。
>
> ````java
> interface Role {       //Role就是接口的名字
>     public void greet();
>     public void move();
>     public int getSpeed();  //接口中不添加修饰符时，默认为public。
> }
> ````
>
> 

## 三、this

> 1. this调用本类中的属性，也就是类中的成员变量；
> 2. this调用本类中的其他方法；
> 3. this调用本类中的其他构造方法，调用时要放在构造方法的首行。

# 异常处理

## 一、捕获异常

> ````java
> try{
>       //将可能有错误的语句放入此处去捕获错误
> }catch(){
>       //如果有满足catch括号里的错误，就输出该大括号里的语句
> }finally{
>       //无论如何都要输出， 无论有错误还是无错误都会输出， 就算在catch里有return，这里的语句也会输出 
> }
> ````
>

## 二、抛出异常 

> + throw: 在函数内抛出一个异常。
> + throws：在函数定义时抛出一些可能的异常。
> + 检查型异常必须被捕获或者抛出。
>
> ![image-20231213214109945](../../../AppData/Roaming/Typora/typora-user-images/image-20231213214109945.png)

# 容器类

一些使用的基本解释：

![image-20231216213235258](../../../AppData/Roaming/Typora/typora-user-images/image-20231216213235258.png)

### 迭代器

![image-20231216223148026](../../../AppData/Roaming/Typora/typora-user-images/image-20231216223148026.png)

![image-20231216223209319](../../../AppData/Roaming/Typora/typora-user-images/image-20231216223209319.png)

![image-20231216223906167](../../../AppData/Roaming/Typora/typora-user-images/image-20231216223906167.png)

![image-20231216224856861](../../../AppData/Roaming/Typora/typora-user-images/image-20231216224856861.png)

# IO流

![image-20231222214415808](../../../AppData/Roaming/Typora/typora-user-images/image-20231222214415808.png)

# 怎么打jar包

> "D:\java\BookCode\out\production\TankWar\com\bjsxt\tank"  这里保存的是整个文件的class

整个程序的图片等应该以相对路径的形式
