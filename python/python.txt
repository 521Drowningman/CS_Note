# python

## 算术运算符

加减乘与c同   求幂用`**`, `2**3`等于8，赋值语句与c同

```
(2+6)/4   //2.0 这是浮点除法即使是整除，最后结果也是带有小数点的数字
7//4   //1  下限除法 最后结果是向下取整
7%4    //1  取模 结果是除法留下的正余数
```

## 布尔运算符

>  `and`运算符
>
> + 当左边为`True`时， 表达式的结果是`and` 右边的表达式的结果；
> + 当左边为`False`时，表达式的结果就是左边的结果
>
> `or`运算符
>
> + 当左边为`True`时，表达式的结果就是左边表达式的结果；
> + 当右边为`False` 时，表达式的结果为右边子表达式的结果。
>
> `not`运算符
>
> + 表达式的结果是，子表达式的反。

## 高阶函数

> 可以接收其他函数作为参数  （这种可以操作函数的函数就叫做高阶函数）
>
> + 柯里化   将一个接受多个参数的函数转换为一个函数链，每个函数接受一个参数

### 拉姆达表达式

lambda 表达式是通过指定两件事来计算函数的表示式：参数和返回表达式。

````python
lambda <parameters>: <return expressing>
````

### nonlocal

将变量声明为外层变量，适用于函数嵌套的情况下。（如高阶函数）

> nonlocal声明的效果是：当前执行帧之外的变量可以通过赋值语句更改。
>
> **在高阶嵌套函数中：若最外层函数有一变量，内层函数可调用该变量，但不可以对该变量进行绑定的更改。**
>
> 即无法修改父帧中定义的变量，但如果该函数在内层函数中声明为nonlocal后，在调用内层函数时便可对该变量进行修改。
>
> ```python
> def make_withdraw(balance):
> 	    def withdraw(amount):
> 	        nonlocal balance   #该函数声明为nonlocal 后便可对其进行修改
> 	        if amount > balance:
> 	            return 'Insufficient funds'
> 	        balance = balance - amount
> 	        return balance
> 	    return withdraw
> 	
> 	wd = make_withdraw(20)
> 	wd(5)
> 	wd(3)
> ```
>
> 



### return语句

````python
return xxx if aaa else bbb   # 这是return语句和 if eles 的混合写法，如果aaa成立则返回xxx 否                                则返回bbb
return 语句也是程序结束语句
````



## in

是一个简单的运算符，只是搜索各个元素进行判断

````python
>>> digits = [1,8,2,8]
>>> 1 in digits 
>>> True

>>> 5 in digits
>>> False
>>> not (5 in digits)
>>> True
````

## 容器

````python
range(-2,2)  #范围 该范围是左开右闭
list(range) #list 是列表构造函数 能将range表示的所有元素换为序列
>>> [-2,-1,0,1]

#列表可以用相加的形式构建
>>> [2] + [1]
 [2,1]       #[2] + 1 是错误的
>>> [] + [1] + [[2,3]]
 [1, [2,3]]    # 这种列表的加法，经常和循环一起使用
>>> [] + [[]] +[[]]   #空的列表也可以相加，从而直接构造一个有足够数量的列表
[[], []]
>>> res = [[], []]
>>> res[0] = res[0] + [1]
>>> res
[[1], []]

列表推导式
[<expression> for <element> in <sequence> if <conditional>]


from functools  import reduce
#reduce 函数可以对某一序列里的数，连续进行某一行为

列表有:
    remove , append , extends函数
#还可直接对部分元素或整个列表进行替换

sorted函数接收一个可迭代对象，并返回一个列表，其中包含可迭代对象的元素，按非递减顺序排列。
如： [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]  #这是一种字典排序方法

>>> a[1,2,3,4,5,6]
>>> a[1:-1]     # -1是指定你不需要的第一个项目
[2,3,4,5]
````

### 字典

````python
{'I':1,'V':5,'X':10}  #由此就创建了字典
>>> nums={'I':1,'V':5,'X':10}   #字典是key: value 形式
>>> nums['X']
>>> 10
字典可以通过赋值的方法扩展
>>> nums['H'] = 88
>>> nums
{'I':1,'V':5,'X':10,'H':88}
#只能由key 得到value 不能反过来由value 得到key
字典构造方法：
>>> dict([(3,9), (4,16), (5,25)])
{3:9, 4:16, 5:25}
字典也有推导式语法，字典推导式会创建一个新的字典对象。
````

+ 字典不能有多个相同的key



### min 函数的key用法

````python
min(<一个序列>， key = <一个函数> )  该函数用于可迭代对象的每一个元素，并根据该函数的返回值来确定最小值。
````

### zip 函数

````python
>>> list(zip([1,2,3],[7,8,9]))
[(1,7),(2,8),(3,9)]   # zip 函数将两个列表合在一起
>>> list(zip([1,2,3], [7,8]))
[(1,7), (2,8)]
````

### 迭代器

````python
iter(iterable)   #该函数返回一个迭代器   iterable 指可以迭代的内容
>>> s=[1,2,3]
>>> t=iter(s)    #此时t就是列表 s 的迭代器 (此时t指向1)
next(iterator)   #iterator 指迭代器
>>> next(t)    #返回迭代器的下一个数  此时t指向2，每次调用迭代器指针会移动
1

>>> list(t) #可一次性将未迭代完的内容 一次性迭代输出 此时迭代指针指向3之后
[2,3]
>>> next(t)
StopIteration  #报错  可以用try语句处理错误
````

> 同一个列表可以不只有一个迭代器：
>
> ![image-20240301113811491](../../AppData/Roaming/Typora/typora-user-images/image-20240301113811491.png)
>
> 如图 `t` 和 `u` 都是列表 `s` 的迭代器但是他们的指向的元素不一样

````python
#字典的 key 和 value 都是可以迭代的数
>>> d = {'one':1,'two':2}
>>> t = iter(d.key())  #可以生成关于key的迭代器
>>> a = iter(d.value()) #生成关于value的迭代器
>>> b = iter(d.items()) #生成关于键值对的元组
如果字典的大小改变，则原来的迭代器无法使用,需要重新生成迭代器
但是如果只是修改了某一个key的value 则不会造成影响
````

````python
for 语句同样可以对迭代器进行遍历
>>> r = range(1,4)
>>> t = iter(r)  #这是r的迭代器  同样是有指向的，其指向r的第一位
>>> for i in t   #对迭代器进行遍历
同样能遍历r的所有数据, 遍历之后迭代器指向r最后一位之后
````

### 内置迭代器

> ````python
> q>>> def double_and_print(x):
>         print('***', x, '=>', 2*x, '***')
>         return 2*x
> >>> s = range(3, 7)
> >>> doubled = map(double_and_print, s)  # double_and_print 未被调用
> >>> next(doubled)                       # double_and_print 调用一次
> *** 3 => 6 ***
> 6
> >>> next(doubled)                       # double_and_print 再次调用
> *** 4 => 8 ***
> 8
> >>> list(doubled)                       # double_and_print 再次调用兩次
> *** 5 => 10 ***                         # list() 会把剩余的值都计算出来并生成一个列表
> *** 6 => 12 ***
> [10, 12]
> ````
>
> 例如：map ，filter ,         zip ,             reversed 函数都返回迭代器
>
> ​                      筛选器  构造二元组          翻转 

### 生成器和Yield语句

> 生成器是由一种特殊类型的函数 **生成器函数** 返回的迭代器。(该函数有惰性计算，不会提前将结果计算出，只有调用时才会开始计算)：
>
> + 调用一次`next`函数,就执行一次`yield`
>
> 生成器函数其主体内无`return`语句, 而是使用`yield`语句。
>
> 当生成器函数中有`return`语句时，`return`语句不会返回任何值，只会终止迭代器进行迭代
>
> 
>
> ````python
> >>> def letters_generator():
>         current = 'a'
>         while current <= 'd':
>             yield current  #该语句标志着，这是生成器函数
>             current = chr(ord(current) + 1)
> 
> >>> for letter in letters_generator():
>         print(letter)
> a
> b
> c
> d
> 
> 如果不用循环，而是自己来动手调用
> >>> letter._next_()
> a
> 
> >>> a = [1,2,3]
> >>> yield from a      #等价于for循环遍历
> ````
>
> 

## 抽象障碍

 在构建大型项目时，要遵守抽象障碍

> 即 改变某一功能代码并不会对其他代码造成影响
>
> 对顶层代码做改变，但是并没有影响其他层代码的功能

## 字符串

````python
str  # 字符串构造函数，可以将任意对象构造成字符串
````



## assert语句

用于在代码中插入断言，用于检查特定条件是否满足。

````python
assert False:"xxxx"   # 这里assert语句后面的条件为'False',这会导致异常，程序会直接结束，若该语                         句在某函数中，则该函数后续的语句都不会在执行了

assert xxx : "xxx"   #正常条件下，若满足该条件，则程序会输出字符串并且程序结束
````



## 树

### 闭包属性

如果一种数据值组合得到的结果也可以用相同的方式进行组合，则该方法具有闭包属性。

> 例如，在一个集合中，若对该集合中的某一元素进行运算生成的仍然是该集合的成员，则该集合被称为在这个运算下闭合。



## 类和对象

对象是类的实现，类是数据和函数的集合

>日期类：具体的日期是日期类的实列对象
>
>````python
>from datetime import date
>
>date 是一个class类
>>>> tues = data(2024,2,18)  #这里创建了一个实列对象
>其实例对象具有日期的功能，可以用一个日期减去另一个日期，由此可以得到两个日期之间的时间间隔
>
>这里的对象也有属性，和其他编程语言一样，可以用点表达式来访问对象的某一属性
>>>> <expression> . <name>
>````
>
>python 中的所有值都是对象，所有的值都有行为和属性，对象即是方法和属性的集合
>
>````python
>如何验证两个对象是否相同
>python 提供了两个操作符
>>>> a = [10]
>>>> b = [10]
>>>> a is b
>False       #这说明a和b 不是同一个对象
>>>> a == b
>True        #这说明二者相等
>````
>
>每个对象都有的函数，在类中应该是共享的。

### 可变数据

如果一个对象的状态可以随着代码的执行而改变，那么它就是可变的。

> 列表和字典都是可变的数据类型
>
> 数字，字符串，元组都不可变

### 元组

任何用逗号分隔的内容都被视为元组 ，括号只是为了表明这是元组 ，无其他作用。

元组是不可变的序列

````python
>>> 4,5,6
(4,5,6)

空元组也是存在的
>>> 3,    #这是只有一个元素的元组
(3,)      #必须要加逗号，没逗号就只是数字

元组也有和序列一样的加法
````

### 点表达式

对象的属性是与对象关联的名称 ，可通过点表达式访问。

```python
a.deposit(15)  #deposit是对象中的函数，当用点表达式调用时返回该函数，所以要使用该函数要传入参数

```

### 自定义类

````python
class <name>:     #class语句可以创建自定义类
    <suite>  #包含一组语句来定义类的属性
    
类的构造函数
>>> class Account:  #第一个 self 绑定到新创建的 Account 对象。第二个参数 account_holder 绑定到调用类进行实例化时传递给类的参数。
   		def __init__(self, account_holder):    #_init_用于初始化对象,是该类的构造函数  
            self.balance = 0
            self.holder = account_holder
            
>>> a = Account('Kirk')   #在创建这个实列时，会调用构造函数，self会自动绑定到正在创建的实例上
>>> c = a #不会创建新的对象，c和a是相同的对象

_init_ 方法用两个下划线是因为这是 表示由Python语言定义的特殊方法。避免为自己的属性使用此命名方案。
````

