# xv6

## 系统调用

1. `exec`在执行调用之后,会将其现在所处进程的内存等全部抛弃,转而运行`exec`打开的指令文件中的内容;所以为了避免`shell`进程被`exec`抛弃,导致执行一个命令后就无法返回`shell`,所以要利用`fork`和`exec`的分离,先fork一个`shell`的副本,再在副本上进行`exec`的调用,由此修改只是子进程,而父进程不会受影响.
2. `write(fd, buf, n)`和`read(fd, buf, n)`系统调用,都会返回其读或写的字节数,但是`write`只会在错误时返回比`n`小的数字;这两个操作进行并发进行,读操作会等待写操作完成一部分或全部数据写入之后才能读取.
3. `int mknod(char *file, int, int)`,创建一个设备文件,后面两个整数参数,分别表示主设备号和辅设备号,这两个设备号唯一确定一个内核设备。
4. 可以通过`fork()`返回的数来区分父子程序。子程序的PID并不是0,而是在子程序中`fork()`会返回0.
5. 在调用`fork()`后,父子进程都会从`fork()`位置之后的代码继续执行,也就是说子进程不会再执行一遍`fork()`之前的代码;那为什么子进程拥有和父进程相同的变量等,这是因为`fork()`会直接拷贝父进程的副本,包括文件标识符和内存.
6. 用`pipe()`创建管道,管道中的数据是单向的,只能从写端流向读端,管道中的数据一旦被读取后就会从管道消失。虽然在读取后,管道中的数据是真的消失了,但是下一次向该管道写入数据时,仍然是紧跟着上次写入数据的末尾继续写入数据,而不会因为上一次写入的数据都消失了,就从管道的头部开始写.(管道用于进程之间进行数据交换,所以一个管道可以横跨父子进程,那么通过这一个管道就可以实现父子间进程的通信).
7. 当管道的write端没有`close()`时,如果此时管道中没有数据,那么read会阻塞.
8. `stat`和`fstat`是用于获取文件或文件系统对象的元数据信息的系统调用`stat`系统调用,接受一个文件路径作为参数;`fstat`接受一个文件描述符作为参数.
9. 目录包含了一组条目,每个条目指向一个文件或子目录.
10. `int exec(char *file, char *argv[])`,假设这里第一个参数传入的是`echo`的文件,那么第二个参数传入的字符串数组的第一个元素应该也是echo;因为命令行参数的第一个元素应该命令本身.

## 文件描述符

在大多数操作系统中,文件描述符`0`、`1` 和 `2` 通常分别对应标准输入（stdin）、标准输出（stdout）和标准错误（stderr）;

如果文件描述符大于`3`,表示这是一个非标准表示符;如果为`-1`,则表示文件打开失败.

+ 一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。

````c
int
getcmd(char *buf, int nbuf)
{
  write(2, "$ ", 2);    // 文件描述符2,表示标准错误,用stderr而不用stdout是因为,stderr没有缓冲区,所以会直接输出
  memset(buf, 0, nbuf); // 将内存的内容全部转换为0,保证用户在输入之前,内存是空的
  gets(buf, nbuf);      // 从标准输入中读取一行字符串,将其存储在内存buf中,nbuf用于限制读取的字节数
  if(buf[0] == 0) // EOF
    return -1;
  return 0;
}
````

```c
// Ensure that three file descriptors are open.
  while((fd = open("console", O_RDWR)) >= 0){  // shell保证总是有3个文件描述符是打开的.这3个文件描述符都是console的
    if(fd >= 3){                               // 默认文件描述符
      close(fd);
      break;
    }
  }
```

## c语言未学知识补充

### C命令行参数

只有使用命令行参数,才可以从命令行获取输入.

如果要使用命令行参数,那么main函数的原型应当是如下两种:

```c
int main(int argc, char *argv[]);
```

或者:

```c
int main(int argc, char **argv[]);
```

+ **`argc` (argument count)**: 表示命令行参数的数量，包括程序名本身。因此，`argc` 至少为 1。

+ **`argv` (argument vector)**: 是一个指向字符串数组的指针，其中每个字符串是一个命令行参数。数组的第一个元素（即 `argv[0]`）通常是程序的名称。接下来的元素是传递给程序的命令行参数。

### c字符串(总忘)

+ C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。数组都由连续存储单元组成，字符串中的字符被存储在相邻的存储单元中,每个存储单元（一字节）存储一个字符。
+ 字符串数组所开辟的空间如果大于字符串所需要的空间,空间剩余部分会被初始化为‘\0’.



## xv6文件

user目录下:

+ 如 sh.d 这种以 `.d`结尾的文件,该文件由`gcc`的编译选项所生成的文件,其内容是`makefile`可识别的依赖关系. `.d`文件存在的原因是:手动维护`makefile`中的依赖关系(如某个 .c 文件会引入哪几个 .h 文件,某些复杂的项目可能会出现嵌套引入 .h 文件,此时继续手动维护这个依赖关系会及其复杂),会导致`makefile`最后难以维护.
+ 如 sh.asm 文件,是汇编语言的源代码文件,可辅助阅读代码和调试.

# 学习笔记

## 第二讲

### 隔离性(isolation)

+ 程序之间应该具有强隔离性,一个程序出现bug不应该影响其他程序的运行.如:当shell运行出现问题时,此时会杀掉其他进程;这非常糟糕.
+ 应用程序和操作系统之间也应该有强隔离性;如:因为应用程序出现问题而导致操作系统崩溃.
+ 如果没有操作系统,那么应用程序会直接与硬件进行交互;这可能导致不同进程之间数据相互覆盖;所以使用操作系统的目的就是为了实现多路复用cpu和内存隔离.
+ 进程本身不是cpu,但是它们对应了cpu;也就是说应用程序不能直接与cpu交互,但是可以与进程交互,操作系统内核会完成不同进程在cpu上的切换,所以进程抽象成了cpu.所以实现cpu切换进程,也就实现了在多个应用程序之间复用一个或多个cpu.
+ files抽象了磁盘,因为应用程序不会直接挂在计算机上的磁盘本身,所以应用程序与存储系统交互的唯一方式就是通过files.

> 硬件对强隔离的支持:
>
> user / kernle mode  和 page table , 虚拟内存

### 防御性(Defensive)

+ 应用程序可能有意或无意向系统调用传入错误参数,如果就此导致操作系统崩溃,那么操作系统会因为崩溃而拒绝为其他的应用程序提供服务.
+ 有些攻击者会想要打破应用程序的隔离,由此获得内核的控制权,为了防止这样的事情发生,应用程序和操作系统之间应该有一堵厚墙来进行防御,这里的强隔离性就是由硬件来实现。

### User / Kernel mode切换

应用程序想调用系统调用,应该将控制权转移给内核:

`ecall`指令就能用来实现这个功能,`ecall`接受一个数字参数,这个数字参数代表应用程序想要调用的系统调用.

此后`ecall`会跳转到内核中的一个特定,由内核控制的系统调用接入点,每一次应用程序执行`ECALL`指令，应用程序都会通过这个接入点进入到内核中。到了内核侧,有一个位于syscall.c的函数`syscall`，每一个从应用程序发起的系统调用都会调用到这个`syscall`函数，`syscall`函数会检查`ECALL`的参数，通过这个参数内核可以知道需要调用的是哪一个系统调用。

### 宏内核和微内核

宏内核:

将整个操作系统代码都运行在kernel mode 中;

优点:

+ 将操作系统中的子模块集成在一个程序中,这样的高度集成提供了很好的性能。

缺点:

+ 在内核中运行了一个巨大的操作系统,出现bug的可能性大,一旦出现bug都会导致内核错误.



微内核:

在kernel mode 中运行足够少的代码,内核中只有非常少的几个模块.

优点:

+ 在内核中代码的数量较少,这样bug也更少.

缺点:

+ 用消息来实现传统的系统调用,需要在user / kernel mode 之间反复跳转,导致产生性能损耗.

## XV6工作过程

代码结构：

> + kernel,这个文件夹中包含了基本上所有的内核文件,因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。
> + user,这个文件夹中包含的基本上是运行在user mode上的程序.
> + mkfs,会创建一个空的文件镜像,这个镜像会存在磁盘上,由此就可以使用一个空的文件系统.
